rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function signedIn() {
      return request.auth != null;
    }
    function isOwner(userId) {
      return signedIn() && request.auth.uid == userId;
    }
    function isProjectOwner() {
      return signedIn() && resource.data.userId == request.auth.uid;
    }
    function isPublicProject() {
      return (resource.data.visibility == null) || (resource.data.visibility == "public");
    }

    // 1) PROFILES
    match /profiles/{userId} {
      allow read: if signedIn();
      allow create: if isOwner(userId);
      allow update: if signedIn() && (
        isOwner(userId) || 
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followersCount', 'followingCount']) &&
          // Validate followersCount delta is +/- 1
          (
             !request.resource.data.diff(resource.data).affectedKeys().hasAny(['followersCount']) ||
             request.resource.data.followersCount == resource.data.followersCount + 1 ||
             request.resource.data.followersCount == resource.data.followersCount - 1
          ) &&
          // Validate followingCount delta is +/- 1
          (
             !request.resource.data.diff(resource.data).affectedKeys().hasAny(['followingCount']) ||
             request.resource.data.followingCount == resource.data.followingCount + 1 ||
             request.resource.data.followingCount == resource.data.followingCount - 1
          )
        )
      );
      
      match /crew/{memberId} {
        allow read, write: if isOwner(userId);
        allow delete: if signedIn() && request.auth.uid == memberId;
      }

      match /ignored_suggestions/{suggestionId} {
        allow read, write: if isOwner(userId);
      }
    }

    // 2) PROJECTS
    match /projects/{projectId} {
      allow create: if signedIn()
        && request.resource.data.userId == request.auth.uid
        && (request.resource.data.visibility == "public" || request.resource.data.visibility == "private");
      allow update: if signedIn()
        && resource.data.userId == request.auth.uid
        && request.resource.data.userId == request.auth.uid
        && (request.resource.data.visibility == "public" || request.resource.data.visibility == "private");
      allow delete: if signedIn()
        && resource.data.userId == request.auth.uid;
      allow read: if signedIn() && (isProjectOwner() || isPublicProject());
    }

    // 3) ESTIMATES - FIXED: Separated create from read/update/delete
    match /estimates/{estimateId} {
      allow read, update, delete: if signedIn() && resource.data.userId == request.auth.uid;
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
    }

    // 4) SERVICES - FIXED: Separated create from read/update/delete
    match /services/{serviceId} {
      allow read, update, delete: if signedIn() && resource.data.userId == request.auth.uid;
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
    }

    // 5) CLIENTS - FIXED: Separated create from read/update/delete
    match /clients/{clientId} {
      allow read, update, delete: if signedIn() && resource.data.userId == request.auth.uid;
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
    }

    // 6) FOLLOWERS
    match /followers/{userId}/list/{followerId} {
      allow read: if signedIn();
      allow write: if signedIn() && (request.auth.uid == followerId || isOwner(userId));
    }
    
    // 7) NOTIFICATIONS
    match /notifications/{userId}/items/{notificationId} {
      allow read, delete: if isOwner(userId);
      // Update (mark as read) only by owner
      allow update: if isOwner(userId);
      // Create only if identifying as self (Anti-spoofing)
      allow create: if signedIn() && request.resource.data.fromUserId == request.auth.uid;
    }

    // 8) POSTS (Social Feed) - IMPROVED: More restrictive update rules
    match /posts/{postId} {
      // Anyone signed in can read public posts
      allow read: if signedIn() && (
        resource.data.visibility == "public" || 
        resource.data.userId == request.auth.uid
      );
      
      // Only the owner can create their own posts
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
      
      // IMPROVED: Only owner can update everything, or others can only update worksCount/commentsCount
      allow update: if signedIn() && (
        resource.data.userId == request.auth.uid ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['worksCount', 'commentsCount'])
      );
      
      // Only owner can delete
      allow delete: if signedIn() && resource.data.userId == request.auth.uid;

      // WORKS sub-collection
      match /works/{workUserId} {
        allow read: if signedIn();
        allow write: if signedIn() && request.auth.uid == workUserId;
      }

      // COMMENTS sub-collection
      match /comments/{commentId} {
        allow read: if signedIn();
        allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
        // Allow updating replyCount
        allow update: if signedIn() && (
          isOwner(resource.data.userId) ||
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['replyCount'])
        );
        allow delete: if signedIn() && (
          resource.data.userId == request.auth.uid || 
          get(/databases/$(database)/documents/posts/$(postId)).data.userId == request.auth.uid
        );

        // REPLIES sub-collection
        match /replies/{replyId} {
          allow read: if signedIn();
          allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
          allow delete: if signedIn() && (
            resource.data.userId == request.auth.uid || 
            get(/databases/$(database)/documents/posts/$(postId)).data.userId == request.auth.uid
          );
        }
      }
    }

    // 9) CHATS
    match /chats/{chatId} {
      // Allow read if user is a participant OR if the chat doesn't exist yet
      // Allowing read on non-existent docs is safe and fixes the initial getDoc() error
      allow read: if signedIn() && (
        (resource == null) || 
        (request.auth.uid in resource.data.participants)
      );
      
      // Allow create if user is in participants list
      allow create: if signedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
      
      // Allow update if user is an existing participant
      allow update: if signedIn() && request.auth.uid in resource.data.participants;

      // Messages sub-collection - SIMPLE: Just check auth
      match /messages/{messageId} {
        allow read: if signedIn();
        allow create: if signedIn() && request.resource.data.senderId == request.auth.uid;
      }
    }
  }
}
